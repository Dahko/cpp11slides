<!doctype html>
<html lang="en">

    <head>
	<meta charset="utf-8">

	<title>C++11/14 with Scott Meyers</title>

	<meta name="description" content="Purely practical overview of several C++11 features">
	<meta name="author" content="Georgy Meshkov">

	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="stylesheet" href="css/reveal.min.css">
	<link rel="stylesheet" href="css/theme/simple.css" id="theme">

	<!-- For syntax highlighting -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- If the query includes 'print-pdf', include the PDF print sheet -->
	<script>
	    if (window.location.search.match(/print-pdf/gi)) {
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = 'css/print/pdf.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	    }
	</script>
	<style type="text/css">
	    p { text-align: left; }
	    .hcenter { text-align: center; }
	    .hcenter *{ text-align: center; }
	    .center { vertical-align: middle; }
	    .center * { vertical-align: middle; }
	    .hl { color: red; }
	</style>


	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
    </head>

    <body>
	<div class="reveal">

	    <!-- Any section element inside of this container is displayed as a slide -->
	    <div class="slides">
		<section>
		<img src="img/luke.png" style="height:70%; width:auto"/>
		<h3>Luke Skywalker on new Jedi techniques</h3>
		</section>
		<section>
		<div style="height:50%">
		    <img src="img/scott.jpeg" style="height:70%; width:auto"/>
		</div>
		<h3>Scott Mayers on new C++11/C++14</h3>
		</section>

		<!-- 
		*
		*
		*
		Lambdas
		*
		*
		*	
		-->

		<section class="center">
			<h1>Lambda expressions</h1>
		</section>

		<section>
		<section>
			<h2>Lambda expressions basics</h2>
			<p><br/></p>
			<p>A quick way to create function objects at their point of use.</p>
			<pre><code data-trim class="cpp">
std::vector&lt;int&gt; v;
…
auto it = std::find_if(v.cbegin(), v.cend(),
                       [](int i) { return i &gt; 0 &amp;&amp; i &lt; 10; });	

			</code></pre>
			<p>Essentially generates:</p>
			<pre><code data-trim class="cpp">
class MagicType1 {
public:
bool operator()(int i) const { return i &gt; 0 &amp;&amp; i &lt; 10; }
};
auto it = std::find_if(v.cbegin(), v.cend(), MagicType1());
			</code></pre>
		</section>

		<section data-transition="none">
			<h2>Lambda expressions basics</h2>
			<p><br/></p>
			<p>A quick way to create function objects at their point of use.</p>
			<pre><code data-trim class="cpp">
std::map&lt;Solution*, int&gt; mapSolID;
...
int someSolId = ...;
...
itInt = std::find_if(
    mapSolID.begin(), mapSolID.end(), ???
);
			</code></pre>
			<pre class="fragment"><code data-trim class="cpp">
class IsEqualSolID
{
public:
    int m_nTarget;
    IsEqualSolID(int nTarget):m_nTarget(nTarget) {}
    bool operator ()(const std::pair&lt;Solution*, int&gt;&amp; a)
    {
        return a.second == m_nTarget;
    }
};

			</code></pre>
		</section>
		<section data-transition="none">
			<h2>Lambda expressions basics</h2>
			<p><br/></p>
			<p>A quick way to create function objects at their point of use.</p>
			<pre><code data-trim class="cpp">
std::map&lt;Solution*, int&gt; mapSolID;
...
int someSolId = ...;
...
itInt = std::find_if(
    mapSolID.begin(), mapSolID.end(), IsEqualSolID(someSolId))
);
			</code></pre>
			<pre><code data-trim class="cpp">
class IsEqualSolID
{
public:
    int m_nTarget;
    IsEqualSolID(int nTarget):m_nTarget(nTarget) {}
    bool operator ()(const std::pair&lt;Solution*, int&gt;&amp; a)
    {
        return a.second == m_nTarget;
    }
};

			</code></pre>
		</section>

		<section data-transition="none">
			<h2>Lambda expressions basics</h2>
			<p><br/></p>
			<p>A quick way to create function objects at their point of use.</p>
			<pre><code data-trim class="cpp">
std::map&lt;Solution*, int&gt; mapSolID;
...
int someSolId = ...;
...
itInt = std::find_if(mapSolID.begin(), mapSolID.end(), 
      [&amp;someSolId](const std::pair&lt;Solution*, int&gt;&amp; a) {
	  return a.second = someSolId;
      }
);
			</code></pre>
		</section>
		</section>


		<!--
		*
		* 
		* Closures
		*
		*
		-->

		<section class="center">
			<h2>Lambdas as closures</h2>
		</section>
		<section>
		<section>
		    <h2>Lambdas as closures</h2>
		    <p><br/></p>
		    <p>Function object created through lambda expressions <br/>are <span class="hl">closures</span>.<br/>
		    Closures may outlive their scope:
		    </p>
		    <pre><code data-trim class="cpp">
std::function&lt;bool(int)&gt; returnClosure(int a) {
    int b, c;
    &hellip;
    return [](int x) { int a*x*x + b*x + c == 0; };
}

auto f = returnClosure(10);
		    </code></pre>
		    <p>In this call:</p>
		    <pre><code data-trim class="cpp">
		    if(f(22) == true) { //... }
		    </code></pre>
		    <p>What are a, b, c? <br/>
		    <code>returnClosure</code> no longer active!</p>

		</section>

		<section>
		    <h2>Lambdas as closures</h2>
		    <p><br/></p>
		    <p>Static and global data is “ok”:</p>
		    <pre><code data-trim class="cpp">
int a; 
std::function&lt;bool(int)&gt; returnClosure() {
    static int b, c;
    &hellip;
    return [](int x) { int a*x*x + b*x + c == 0; };
}
  auto f = returnClosure(10);
		    </code></pre>
		    <p>Otherwise local variables have to be <span class="hl">captured</span></p>
		</section>

		<section>
		    <h2>Capturing local variables</h2>
		    <p><br/></p>
		    <p>Capturing locals puts copies in closures:</p>
		    <pre><code data-trim class="cpp">
{
    int minVal;
    double maxVal;
   …
    auto it = std::find_if(v.cbegin(), v.cend(),
                          [minVal, maxVal](int i)
                          { return i &gt; minVal &amp;&amp; i &lt; maxVal; }
    );
}
		    </code></pre>
		    <p>Essentially corresponds to:</p>
		    <pre><code data-trim class="cpp">
class MagicType {
public:
    MagicType(int v1, double v2): _minVal(v1), _maxVal(v2) {}
    bool operator()(int i) const { return i &gt; _minVal &amp;&amp; i &gt; _maxVal; }
private:
    int _minVal;
    double _maxVal;
};
auto it = std::find_if(v.cbegin(), v.cend(), MagicType(minVal, maxVal));
		    </code></pre>
		</section>
		<section>
		    <h2>Capturing local variables</h2>
		    <p><br/></p>
		    <p>Capturing locals puts copies in closures:</p>
		    <pre><code data-trim class="cpp">
{
    int minVal;
    double maxVal;
   …
    auto it = std::find_if(v.cbegin(), v.cend(),
                          [&minVal, &maxVal](int i)
                          { return i &gt; minVal &amp;&amp; i &lt; maxVal; }
    );
}
		    </code></pre>
		    <p>Essentially corresponds to:</p>
		    <pre><code data-trim class="cpp">
class MagicType {
public:
    MagicType(int& v1, double& v2): _minVal(v1), _maxVal(v2) {}
    bool operator()(int i) const { return i &gt; _minVal &amp;&amp; i &gt; _maxVal; }
private:
    int& _minVal;
    double& _maxVal;
};
auto it = std::find_if(v.cbegin(), v.cend(), MagicType(minVal, maxVal));
		    </code></pre>
		</section>
		<section>
		    <h2>Capturing local variables</h2>
		    <p><br/></p>
		    <p>Capture mode defaults may be specified:</p>
		    <pre><code data-trim class="cpp">
auto it = std::find_if( v.cbegin(), v.cend(),   // default is
                      [=](int i)                // by value
                      { return i &gt; minVal &amp;&amp; i &lt; maxVal; });
auto it = std::find_if( v.cbegin(), v.cend(),   // default is
                      [&amp;](int i)                // by ref
                      { return i &gt; minVal &amp;&amp; i &lt; maxVal; });
		    </code></pre>
		    <p>Default overridable on a per-variable basis:</p>
		    <pre><code data-trim class="cpp">
auto it = std::find_if(v.cbegin(), v.cend(),
                       [=, &amp;maxVal](int i) 
                       { return i &gt; minVal &amp;&amp;      // minVal by value
                                i &lt; maxVal; });    // maxVal by reference
		    </code></pre>
		</section>

		<section>
		    <h2>Lambda Return Types</h2>
		    <p><br/></p>
		    <p>Optional when:</p>
		    <ul>
			<li>Return type is void.</li>
			<li>Lambda body is “return expr;”
			    <ul><li>Return type is that of expr.</li></ul>
			</li>
		    </ul>
		    <p><br/></p>
		    <p>Otherwise must be specified via trailing return type syntax:</p>
		    <pre><code data-trim class="cpp">
std::vector&lt;double&gt; v;
&hellip;
std::transform(v.begin(), v.end(), v.begin(),
              [](double d)-&gt;double
              {
                  makeLogEntry(&quot;std::transform&quot;, d);
                  return std::sqrt(std::abs(d));
              }
);

		    </code></pre>
		</section>

		<section>
		    <h2>C++14</h2>
		    <p><br/></p>
		    <p>Return type deduction valid for <span class="hl">all</span> functions. Argument type deducion.</p>
		    <pre><code data-trim class="cpp">
auto magicValue1(int seed) // both returns are int
{
    if (seed &gt;= 0) return seed;
    else return 42;
}
std::partition( d.begin(), d.end(),
                [] (auto val) // -&gt;bool not required, val type automatic
                { if (val % 10 == 0) return true;
                  return false; }
);
		    </code></pre>
		    <p>Init captures</p>
		    <pre><code data-trim class="cpp">
return [ minVal = computeMinVal(this-&gt;minSeed) ] (int x)
       { return minVal &lt;= x };
		    </code></pre>

		</section>

		<section>
		    <h2>Тонкости</h2>
		    <p><br/></p>
		    <ul>
			<li>Захват членов класса (надо захватывать this, по значению невозможно)</li>
			<li>У лямбды без параметров скобки можно опустить: <br/>[]{ //body }</li>
			<li>Лямбды могут все, что и обычные функции. Но Скотт рекомендует не увлекаться и писать короткие, понятные лямбды, вытекающие из контекста.</li>
			<li>Лямбды по умолчанию константны, но бывают mutable lambdas.</li>
		    </ul>
		    <p><br/></p>
		</section>

		</section> <!-- // lambdas as closures-->

		<!--
		*
		* 
		* std::function
		*
		*
		-->

		<section class="center">
		<h2>std::function</h2>
		</section>

		<section>
		<section>
		    <h2>Storing lambdas</h2>
		    <p><br/></p>
		    <p>Ранее мы рассматривали простые примеры, когда лямбда создается и сразу же используется в алгоритме stl.</p>
		    <pre><code data-trim class="cpp">
std::vector&lt;int&gt; v;
…
auto it = std::find_if(v.cbegin(), v.cend(),
		       [](int i) { return i &gt; 0 &amp;&amp; i &lt; 10; });	
		    </code></pre>
		    <p>Когда мы обсуждали захват переменных, было понятно, что захват по значению нужен именно для отложенного запуска лямбд.</p>
		    <p>Как же хранить лямбды?</p> 
		</section>

		<section>
		    <h2>Auto</h2>
		    <p><br/></p>
		    <pre><code data-trim class="cpp">
??? fn = [](MyClass* x) { return x-&gt;IsGood(); }
		    </code></pre>
		    <pre class="fragment"><code data-trim class="cpp">
auto fn = [](MyClass* x) { return x-&gt;IsGood(); }
		    </code></pre>
		    <blockquote class="hcenter fragment">"Let's make it available <span class="hl">everywhere</span>!"</blockquote>
		    <div class="fragment">
		    <pre><code data-trim class="cpp">
auto x1 = 10;        // x1: int
std::map&lt;int, std::string&gt; m;
auto i1 = m.begin(); // i1: std::map&lt;int, std::string&gt;::iterator
for(auto i = m.begin(); i!=m.end(); i++) { i-&gt;second+="!"; }
		    </code></pre>
		    <p>Auto variables have the type of their initializing expression.</p>
		    <p>Const/volatile and reference/pointer adornments may be added:</p>
		    <pre><code data-trim class="cpp">
const auto *x2 = &x1; // x2: const int*
const auto& i2 = m;   // i2: const std::map&lt;int, std::string&gt;&
auto ci = m.cbegin(); // ci: std::map&lt;int, std::string&gt;::const_iterator
		    </code></pre>
		    <p>Выведение типа аналогично выведению типа в шаблонах.</p>
		    </div>
		</section>
		

		</section> <!-- // std::function -->

		<!--
		*
		* 
		* Real world lambdas
		*
		*
		-->

		<section class="center">
		<h2>Real-world lambda usage</h2>
		</section>

		<section>
		<section>
		<h2>"Command" pattern</h2>
		<p><br/></p>
		    <pre><code data-trim class="cpp">
class CReflectSeriazableFactoryFace {
public:
    CReflectSeriazableFactoryFace();
    virtual ISerializableFace* MakeSerializableObject( 
                               GUID const&amp; serialId );
    virtual unsigned ObjectTypesCount() { return m_map.size(); }
    virtual GUID GetObjectGUID(unsigned i);
protected:
    std::map&lt;GUID, std::function&lt;IDocumentNode*()&gt;&gt; m_map;
}
		    </code></pre>
		    <pre><code data-trim class="cpp">

CReflectSeriazableFactoryFace::CReflectSeriazableFactoryFace() {
    m_map[SERID_IPOLYHEDRONNode] = []{ return new CModelNodeImpl; };
    m_map[SERID_IReflectDataNode] = []{ return new CReflectDataNode; };
}
ISerializableFace* CReflectSeriazableFactoryFace::MakeSerializableObject( 
                                                 GUID const&amp; serialId ) {
    auto creator = m_map.find(serialId);
    if(creator == m_map.end()) return NULL;

    IDocumentNode *node = creator-&gt;second();
    if(!node) return NULL;

    CDocumentNodeCommonSerializer * wrapper =
                new CDocumentNodeCommonSerializer(node);
    return wrapper;
}
		    </code></pre>

		</section>

		<section>
		<h2>Functional programming</h2>
		<p><br/></p>
		    <pre><code data-trim class="cpp">
std::map&lt;int, std::string&gt; m;
typedef m::value_type MyMapVal;

for(auto i = m.begin(); i!=m.end(); i++) { i-&gt;second+="!"; }
std::foreach(m.begin(), m.end(), [](MyMapVal & i) { i.second+="!"; }
		    </code></pre>
		<p>Чем второй вариант може быть лучше первого?</p>
		<div class="fragment">
		    <p>В случае с лямбдой мы работаем не с итератором, а со значением, так что не можем "испортить" итератор.</p>
		    <pre><code data-trim class="cpp">
for(auto i = m.begin(); i!=m.end(); i++) { i-&gt;second+="!"; i++; }
std::foreach(m.begin(), m.end(), [](MyMapVal & i) { i.second+="!"; /*i++;*/ }
		    </code></pre>
		<div>
		<div class="fragment">
		    <p>Функциональный стиль - максимально ограничиваем множество доступные коду данных, чтобы минимизировать побочные эффекты. Такой код надежнее и легче тестируется.</p>
		    <p>Коду внутри лямбд доступны только их параметры и захваченные переченные (поэтому лучше избегать [&] и [=]).</p>
		<div>
		</section>
		</section> <!-- real-world lambda usage -->


















	    </div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.min.js"></script>

	<script>

	    // Full list of configuration options available here:
	    // https://github.com/hakimel/reveal.js#configuration
	    Reveal.initialize({
		controls: true,
		progress: true,
		history: true,
		center: false,
		slideNumber: true,

		theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
		transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
		transitionSpeed: 'fast',

		width: 1200,

		keyboard: {
		    8: 'prev' // go to the previous slide when the backspace key is pressed
		},

		// Optional libraries used to extend on reveal.js
		dependencies: [
		{ src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
		// Zoom in and out with Alt+click
		{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } }

		]
	    });

	</script>

    </body>
</html>

